\documentclass[sigconf]{acmart}

\usepackage{xspace}
% \usepackage{amsmath}
\usepackage{listings}
\usepackage{subcaption}

\lstset{
  mathescape=true,
  language=SQL,
  columns=flexible,
  keepspaces=true,
  showstringspaces=false,
  stringstyle=\slshape\color{green!40!black},
  basicstyle=\ttfamily\small,
  morekeywords={*, self},
  commentstyle=\slshape\color{black!60},
  tabsize=2,
}


\begin{document}

\title{No More Nulls!}
\author{Yisu Remy Wang}
\affiliation{%
  \institution{University of Washington}
  \city{Seattle, WA}
  \country{USA}
}
\email{remywang@cs.washington.edu}

\begin{abstract}
Since the inception of SQL, 
 nulls have frustrated database users and builders alike.
Those writing SQL must painstakingly
 guard their queries agaist surprising results caused by nulls,
 while those building database engines
 constantly struggle to implement the subtle semantics of 3-valued logic.
Given that the relational model already provides a way 
 to represent missing information,
 namely, the absence of a tuple in a relation,
 one may step back and ask: ``Are nulls really necessary?''
We answer ``No!'' by proposing a new semantics for SQL
 that completely eliminates nulls.
Our semantics, called Columnar Semantics, 
 is as expressive as the standard 3-valued logic semantics,
 and behaves the same when the data and query are null-free.
Where the two semantics differ, Columnar Semantics results in simpler queries.
\end{abstract}

\maketitle

\section{Introduction}
Nulls in SQL are a pain.
Among many others,
 both the founder of the relational model, Codd~\cite{DBLP:books/aw/Codd90},
 and a co-inventor of SQL, Chamberlin~\cite{DBLP:conf/sigmod/Chamberlin23},
 have lamented the countless bugs caused by nulls,
 in both the database engine and the application code.
The current SQL standard supports nulls via 3-valued logic,
 which is a common source of confusion for developers~\cite{10.1145/3596673.3603142}.
Surprisingly, many attempts to address the problem of nulls
 have focused on increasingly complex many-valued logics~\cite{
  DBLP:conf/kr/ConsoleGL16,
  DBLP:journals/sigmod/Date08,
  DBLP:journals/sigmod/Gessert90,
  DBLP:conf/future/JiaFM92,
  10.1145/126482.126487} (all the way to 6-valued logic!).
These proposals have not seen wide adoption,
 because they are even harder to understand than 3-valued logic.
A recent work by Peterfreund and Libkin~\cite{DBLP:conf/pods/LibkinP23}
 goes the other direction, towards simplicity:
 they show that the textbook 2-valued logic suffices to capture 
 the semantics of SQL in the presence of nulls.
In this paper, we go a step further and argue that \textbf{nulls can be removed altogether}
 from the SQL language.
Our key insight is simple: nulls were invented to represent missing information,
 yet the relational model without nulls already provides a way to indicate information
 is missing, namely, with the absence of a tuple in a relation.
But what if only part of a tuple is missing?
Our solution is to decompose each relation into a collection of (correlated) columns,
 and an absent entry in a column thus represents missing information
 in the corresponding attribute of the tuple.
Specifically, \textbf{we propose Column Normal Form, 
 a new data normal form} inspired by Sixth Normal Form~\cite{DBLP:books/daglib/0014409} 
 and Graph Normal Form~\cite{RAIDocumentation}.
Based on Column Normal Form,
\textbf{we propose Columnar Semantics, a new semantics for SQL}
 where the query operates on a collection of columns instead of a collection of rows.

Column Normal Form improves upon the previous normal forms by allowing missing 
 information in any part of the tuple,
 even when the relation already satisfies no non-trivial dependencies.
Columnar Semantics satisfies the desiderata put forward by~\cite{DBLP:conf/pods/LibkinP23}:
 \begin{enumerate}
  \item It is as expressive as the standard 3-valued logic semantics.
  \item For null-free data and query, the behavior is identical to the standard semantics.
  \item When the two semantics differ, Columnar Semantics results in simpler queries.
 \end{enumerate}
While the first two criteria can be defined formally,
 the third one is rather subjective.
Peterfreund and Libkin~\cite{DBLP:conf/pods/LibkinP23} provides one interpretation 
 by measuring the size of the query.
We achieve simplicity by completely eliminating the complexity of nulls from all queries. 

The idea of handling nulls via normalization is not new.
LogicBlox and RelationalAI have built
 successful commercial databases based on Sixth Normal Form
 and Graph Normal Form~\cite{
  DBLP:books/daglib/0014409,
  RAIDocumentation,
  DBLP:conf/sigmod/ArefCGKOPVW15}.
In his keynote speech~\cite{DBLP:conf/sigmod/Chamberlin23},
 Chamberlin also pointed to normalization as 
 one of the two candidate solutions 
 to the problem of missing information.
He also brought up the common criticism of normalization:
 decomposing the relations introduces additional joins,
 degrading query performance.
We follow a simple solution to this problem
 proposed by Peterfreund and Libkin~\cite{DBLP:conf/pods/LibkinP23}: 
 since our semantics is as expressive as the standard one,
 every query under our semantics can be {\em compiled} 
 into another query under the standard semantics,
 which is then executed by existing database engines.
In other words, we provide our null-free semantics as a
 ``front-end'', or ``user interface'', to the  programmer,
 while the ``back-end'' database engine remains unchanged.
On the other hand, the simpler semantics may also enable
 more sophisticated query optimization and execution techniques, 
 as evident in~\cite{DBLP:conf/pods/LibkinP23,DBLP:conf/sigmod/ArefCGKOPVW15,RAIDocumentation}.
In the future, more innovative systems can 
 directly implement Columnar Semantics 
 to take advantage of such opportunities.

The rest of this paper is organized as follows.
Section~\ref{sec:background} reviews background 
 on missing information in SQL and discusses related work.
Section~\ref{sec:cnf} introduces Column Normal Form and Columnar Semantics.
Section~\ref{sec:cv3} compares Columnar Semantics with the standard 3-valued logic semantics, 
 and show them to be equally expressive.
Finally, Section~\ref{sec:conclusion}
 lays out future research directions and concludes.

\section{Background and Related Work}
\label{sec:background}

The history of nulls in SQL is almost as old as SQL itself,
 stretching back to the inception of the relational model some 50 years ago.
We therefore do not attempt to provide a comprehensive survey of the literature, 
 but rather focus on the fundamentals and the most relevant research.
In this section, we first review the standard semantics of SQL
 based on 3-valued logic.
Then, we discuss prior work on missing information that directly 
 inspired our approach,
 including data normalization and semantics based on 2-valued logic.

\subsection{SQL and 3-Valued Logic}
We present here a condensed overview of SQL and its semantics,
 aiming to provide intuition rather than completeness.
Our technique supports the full set of relational algebra 
 defined in~\cite{DBLP:conf/pods/LibkinP23}.

A {\em query} has the form:
%
\lstinline[mathescape=true]|SELECT $\vec{e},\vec{\gamma}$ FROM $\vec{R}$ WHERE $\phi$ GROUP BY $\vec{v}$|,
%
where $\vec{e}$ is a list of expressions,
 $\vec{\gamma}$ is a list of aggregate expressions,
 $\vec{R}$ is a list of relations,
 $\phi$ is a formula,
 and $\vec{v}$ is a list of attributes.
An {\em expression} is built up with functions 
 (like $+$ and $\times$),
 constants, and attributes;
 an {\em aggregate expression} is an
 aggregate funciton 
 (like \lstinline[mathescape=true]|COUNT| 
 and \lstinline[mathescape=true]|SUM|)
 applied to an expression;
 a {\em formula} consists of predicates over expressions
 (e.g., $e_1 = e_2$ and $e_1 < e_2$) 
 connected by the logical connectives 
 \lstinline|AND|,
 \lstinline|OR|, and
 \lstinline|NOT|.
We omit features like 
 \lstinline|IN|,
 \lstinline|ANY|, 
 \lstinline|ALL|,
 and subqueries, 
 as they can be eliminated via standard techniques~\cite{DBLP:conf/pods/LibkinP23, DBLP:conf/btw/0001K15}.
 
Without aggregates, the meaning of a query can be understood
 as follows:
 we nondeterministically choose a tuple
 from each relation in $\vec{R}$ 
 and evaluate the formula $\phi$ over them;
 if $\phi$ evaluates to true,
 we evaluate each expression in $\vec{e}$ and outout the result.
To evaluate aggregation,
 we first compute the tuples as above,
 then group them by the attributes in $\vec{v}$,
 and finally apply the aggregate function to each group.
When evaluating an expression or applying an aggregate function, 
 any null input results in a null output.
A predicate returns \lstinline|UNKNOWN| if 
 any of its arguments is null;
 one exception is the predicate \lstinline|IS NULL|
 which returns \lstinline|TRUE| if its argument is null,
 and \lstinline|FALSE| otherwise.
In a formula, truth values are propagated
 following Kleene's 3-valued logic as follows, 
 where $t$ stands for \lstinline|TRUE|, 
 $f$ for \lstinline|FALSE|, and $u$ for \lstinline|UNKNOWN|:

\begin{tabular}{ c|ccc } 
  \lstinline|AND| & t & f & u \\ 
  \hline
  t & t & f & u \\
  f & f & f & f \\
  u & u & f & u
\end{tabular}\qquad
%
\begin{tabular}{ c|ccc } 
  \lstinline|OR| & t & f & u \\ 
  \hline
  t & t & t & t \\
  f & t & f & u \\
  u & t & u & u
\end{tabular}\qquad
%
\begin{tabular}{ c|c } 
  \lstinline|NOT| &  \\ 
  \hline
  t & f \\
  f & t \\
  u & u 
\end{tabular}\quad

\begin{example}
\label{ex:sql}
The 3-valued logic semantics can produce surprising results.
Consider the query \lstinline|SELECT * FROM R WHERE R.x = R.x|.
One would expect the result to be the same as the relation \lstinline|R|,
 due to the reflexivity of equality.
However, because \lstinline|=| returns \lstinline|UNKNOWN| 
 when either argument is null,
 the query drops all entries 
 where \lstinline|x| is null.
\end{example}

Surprises like Example~\ref{ex:sql} 
 can lead to subtle bugs in SQL queries. 
They also complicate the implementation of database engines, 
 as common algebraic properties like the reflexivity of equality
 can no longer be assumed when authoring optimization rules.

\subsection{Handling Nulls with 2-Valued Logic}

One source of confusion in 3-valued logic
 is the unfamiliar behavior of \lstinline|UNKNOWN|.
Most developers are accustomed to 2-valued logic,
 where the only truth values are \lstinline|TRUE| and \lstinline|FALSE|.
Fortunately, and perhaps surprisingly,
 2-valued logic can already capture the semantics of SQL 
 in the presence of nulls, 
 as shown by Peterfreund and Libkin~\cite{DBLP:conf/pods/LibkinP23}.
Their semantics requires only a simple modification:
 whenever an argument to a predicate is null,
 return \lstinline|FALSE| instead of \lstinline|UNKNOWN|.
This way, query evaluation may proceed purely in 2-valued logic
 following the standard semantics of the logical connectives.
Peterfreund and Libkin proved their new semantics 
 agrees with the standar 3-valued logic semantics
 when the data and query are null-free,
 and the two semantics have exactly the same expressive power.
Consequently, every query under the new semantics
 can be compiled into another query under the standard semantics,
 which is to be executed by an existing database engine.
In other words, adopting the new semantics 
 incurs no performance penalty,
 assuming a sufficiently sophisticated compiler.

Nevertheless, the new semantics is not without 
 controversy\footnote{The author of this paper was sandwiched between the two sides of 
 a passionate debate during the Q\&A session of~\cite{DBLP:conf/pods/LibkinP23}.}.
For example, neither \lstinline|NULL = NULL| nor \lstinline|NULL $\neq$ NULL|
 is true, defying the intuition that \lstinline|NULL $\neq$ NULL|
 is the same as \lstinline|NOT (NULL = NULL)|.
% Moreover, because \lstinline|NULL = NULL| is false, 
%  the query in Example~\ref{ex:sql} still drops null entries.
Peterfreund and Libkin resolves this with
 a more complex interpretation of comparisons,
 but it's not clear if this alternative interpretation
 introduces further complications.
It appears our troubles will not end, 
 as long as nulls remain.

\subsection{Eliminating Nulls via Decomposition}
One alternative to nulls is to simply
 use the absence of a tuple to indicate missing information.
But when only part of a tuple is missing, 
 dropping the entire tuple loses information.
A solution is to decompose the relation into smaller ones
 such that each tuple is represented by the join 
 of smaller pieces, and each piece can be missing.
Usually, the relation is decomposed into a certain 
 {\em normal form}, 
 for example Sixth Normal Form~\cite{DBLP:books/daglib/0014409}
 and Graph Normal Form~\cite{RAIDocumentation}.
A relation is in normal form if it cannot be decomposed further,
This is the approach implemented by LogicBlox 
 and RelationalAI~\cite{RAIDocumentation,DBLP:conf/sigmod/ArefCGKOPVW15},
 and advocated by Date et.al.~\cite{DBLP:journals/sigmod/Date08,DBLP:books/daglib/0014409}.
We illustrate the idea with an example.

% \begin{figure}
% \begin{subfigure}[c]{0.6\linewidth}
% \begin{tabular}{|c|c|c|}
% \hline
% \textsf{Author} & \textsf{Institute} & \textsf{Address} \\ 
% \hline
% Codd & IBM & San Jose \\
% Chamberlin & IBM & \lstinline|NULL| \\
% Boyce & \lstinline|NULL| & San Jose \\
% \hline
% \end{tabular}
% \end{subfigure}
% \begin{subfigure}[c]{0.39\linewidth}
% \centering
% \begin{tabular}{|c|c|}
% \hline
% \textsf{Author} & \textsf{Institute} \\
% \hline
% Codd & IBM \\
% Chamberlin & IBM \\
% \hline
% \end{tabular}

% \vspace{1em}
% \centering
% \begin{tabular}{|c|c|}
% \hline
% \textsf{Author} & \textsf{Address} \\ 
% \hline
% Codd & San Jose \\
% Boyce & San Jose \\
% \hline
% \end{tabular}
% \end{subfigure}
% \caption{A table with nulls and its decomposition.}
% \end{figure}

\begin{figure}
\begin{subfigure}{\linewidth}
\centering
\begin{tabular}{|c|c|c|}
\hline
\textsf{Author} & \textsf{Institute} & \textsf{Address} \\ 
\hline
Codd & IBM & San Jose \\
Chamberlin & IBM & \lstinline|NULL| \\
Boyce & \lstinline|NULL| & San Jose \\
\hline
\end{tabular}
\caption{Missing information is marked with \lstinline|NULL|.}
\label{fig:table-null}
\vspace{1em}
\end{subfigure}
\begin{subfigure}{\linewidth}
\centering
\begin{tabular}{|c|c|}
\hline
\textsf{Author} & \textsf{Institute} \\
\hline
Codd & IBM \\
Chamberlin & IBM \\
\hline
\end{tabular}
\hspace{1em}
\begin{tabular}{|c|c|}
\hline
\textsf{Author} & \textsf{Address} \\ 
\hline
Codd & San Jose \\
Boyce & San Jose \\
\hline
\end{tabular}
\caption{Decomposition into two null-free relations.}
\label{fig:table-normalized}
\end{subfigure}
\caption{A relation with nulls and its decomposition.}
\end{figure}

\begin{example}
\label{ex:normalization}
Consider the relation in Figure~\ref{fig:table-null}, 
 where two values are missing and marked with \lstinline|NULL|.
It can be decomposed into the two relations in Figure~\ref{fig:table-normalized}
 which hold the same information, but do not use nulls.
\end{example}

After decomposing every relation into ones without nulls,
 queries can be evaluated with the standard 2-valued logic semantics.
However, it is not always possible to fully eliminate nulls via decomposition.
In Example~\ref{ex:normalization}, 
 we have implicitely assumed the \textsf{Author} attribute 
 to be a key and may never be missing.
But if we add a tuple 
%
\begin{tabular}{|c|c|c|}
\hline
\lstinline|NULL| & UW & Seattle\\
\hline
\end{tabular}
%
 to the relation, 
 then the relation cannot be decomposed at all.
In other words, decomposition assumes at least one column must never contain nulls. 
Another common criticism of decomposition is that
 it introduces additional joins in each query, 
 which can degrade performance and readability.
For example, every join with the table in Figure~\ref{fig:table-null}
 then becomes two joins with both tables in Figure~\ref{fig:table-normalized}.

We will see how the above shortcomings can be addressed 
 by Column Normal Form and Columnar Semantics.
Specifically, we allow missing information in any part of the relation;
 the query is as readable as the original one, and in many cases idential;
 and it is always possible to compile the query into the original one,
 losing no performance at all.

\section{Column Normal Form and Columnar Semantics}
\label{sec:cnf}

\section{Capturing SQL with Columnar Semantics}
\label{sec:cv3}

\section{Discussion}
\label{sec:conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{nulls}

\end{document}
